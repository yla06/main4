<?php
require_once "{$_SERVER[ 'DOCUMENT_ROOT' ]}/model/model/Blog.php";
require_once "{$_SERVER[ 'DOCUMENT_ROOT' ]}/model/model/Comment.php";

/**
 * При использовании адаптеров моделей которые работают с БД, необходимо ДО
 * создания первой модели указать настройки соединения с БД. Обычно это делается
 * в файле конфига
 */
DBAbstract::$host = 'localhost';
DBAbstract::$user = 'test1';
DBAbstract::$pass = '12345q';
DBAbstract::$db   = 'test1';

/**
 * Модель блога. Работает на файлах.
 */
$blog          = new Blog;
$blog -> title = 'Заголовок блога';
$blog -> text  = 'Текст блога';
//$blog -> id    = 123;
//$blog -> save() или $blog -> insert();
/**
 * Метод save сам определит что делать, добавлять или менять запись
 * Метод insert создает запись
 *
 * Если у модели не заполнен алиас id, это означает, что метод save создаст запись.
 * Если алиас существует: $blog -> id = 123; модель отработает на замену данных
 * записи с id = 123
 */

//$blog -> delete( 2 );// Удаляет запись с ID = 2

$blog = Blog::selectById( 2 );
/**
 * Метод selectById выбирает запись по ее идентификатору, создает модель,
 * заполняет ее выбранными данными и возвращает.
 * ОДИН объект модели должен содержать ОДНУ запись в таблице или запись в файле
 * согласно шаблону проектирования ORM "ActiveRecord"(читайте гугл).
 *
 * Этот подход достаточно удобен в использовании поскольку в большинстве случаев
 * в веб-программировании будете работать именно с одним рядом. Имея заполненную
 * данными модель можно работать с ней используя любые методы класса моделей.
 *
 * По сути, эта модель используется для того, чтобы можно было указывать методами
 * что делать с записью без явного использования SQL запросов или кода для работы с ФС.
 *
 * Примеры:
 * Если представить, что запись в таблице блога имеет 100 записей, при выборке
 * данных методом selectById создается объект модели и она автоматом заполняется
 * всеми данными согласно алиасам, что описаны в модели блога, далее если в
 * объекте вызвать метод insert() он создаст копию этой записи. Если вызвать метод
 * save или update эта запись обновить данные. Обычно выбирая один ряд данных
 * есть необходимость или получить какое либо ее значение, или получить массив
 * выбранных данных или изменить значения нескольких столбцов:
 * echo $blog -> title; // Вывод заголовка блога
 * $arr = $blog -> fetch(); // Получение массива всех данных ряда(массив со 100 столбами)
 *
 * $blog -> title = 'Новый заголовок';
 * $blog -> foo = 'Новое значение столбца foo';
 * $blog -> bar = 'Новое значение столбца bar';
 * ...
 * $blog -> update();// Происходит замена значение столбцов title, foo, bar
 */


/**
 * Метод selectAll выбирает все записи которые есть в БД или в файле и при возврате
 * КАЖДЫЙ результирующий набор данных возвращает как отдельный объект модели, чтобы
 * при переборе этого массива данных, в "as $model" выбло записано объект текущей
 * перебираемой модели с которой снова же работаем на основе методов этой модели.
 */
foreach ( Blog::selectAll() as $model )
{
  // Пример получения привычного массива данных одной записи
  echo '<pre>';
  print_r( $model -> fetch() );
  echo '</pre>';

  // Пример вывода данных одной записи:
  // echo "<h2>{$model -> title}</h2><div class=\"text-blog\">{$model -> text}</div>";

  /**
   * Пример удаления записей у которых в столбце foo записано 1
   *  if ( $model -> foo === '1' )
   *    $model -> delete( ; )
   *
   * обычно модели AR(ActiveRecord) должеы содержать гораздо больше методов для
   * работы с данными которые в этой модели я не описывал. Поэтому пример выше
   * обычно никто не использует. Пример попроще, что делает тоже самое:
   *
   * deleteById( 1 ) удаляет запись по ID | WHERE `id` = 5
   *
   * deleteByAttr( ['foo' = 1, 'bar' => 5] ) удаляет запись по атрибутам |
   * WHERE `foo` = 1 AND `bar` = 5
   *
   * updateById, updateByAttr, insertMultiple, selectByAttr, count, countByAttr,
   * initRel, setLimit, setOrder, setGroup, setSelectExpr, start/closeTransaction,
   * before(init, update, select, insert, delete)
   * after(init, update, select, insert, delete)
   * и другие методы использование
   * которых может позволить на некоторых проектах не писать ВООБЩЕ ни одного запроса к БД
   * или кода для работы с ФС
   */

  /**
   * В двух словах, модели используются для удобства в работе с данными проекта
   * и ускорения скорости написания проекта. Модели достаточно толстые и иногда
   * медленно работают на крупных проектах или больших данных. Использование моделей
   * позволяет описывать изменения в данных с помощью ООП. Вполне реально даже
   * написать проект в котором не будет написано ни одного запроса к БД потому что
   * построением их и запросами будет заниматься модель. Более подробно изучать модели
   * мы будем при изучении проектирования проектов и MVC в частности. Этот материал
   * я даю для понимания всего что есть в ООП. Это интерфейсы, абстрактные классы,
   * трейты, статика, наследование, инкапсуляция, полиморфизм, класс, объект, как
   * объекты между собой работают и прочее.
   */
}
